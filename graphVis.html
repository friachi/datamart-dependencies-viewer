<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
        .node {}
        .edgepath { fill: none; stroke: #999; stroke-opacity: .6; stroke-width: 1px; }

    </style>
</head>
<body>
<svg width="960" height="600"></svg>

<script src="http://d3js.org/d3.v4.min.js" type="text/javascript"></script>
<script src="http://d3js.org/d3-selection-multi.v1.js"></script>

<script type="text/javascript">

var legend = {
    "Batch of extractions" : { color: "#F8B624" },
              "Extraction" : { color: "#D88A8A" },
          "Datamart table" : { color: "#84D663" },
               "DBF table" : { color: "#B3B02D" },
           "Label of data" : { color: "#57A800" },
           "Dynamic table" : { color: "#8CC6ED" }
};

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        node,
        link;

    svg.append('defs').append('marker')
        .attrs({'id':'arrowhead',
            'viewBox':'-0 -5 10 10',
            'refX':13,
            'refY':0,
            'orient':'auto',
            'markerWidth':13,
            'markerHeight':13,
            'xoverflow':'visible'})
        .append('svg:path')
        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
        .attr('fill', '#999')
        .style('stroke','none');

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) {return d.id;}).distance(100).strength(1))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));

    d3.json("JSONGraph.json", function (error, graphfile) {
        if (error) throw error;
        update(graphfile.graphs[0].edges, graphfile.graphs[0].nodes);
    })

    function update(links, nodes) {

    //sort links by source, then target
      links.sort(function(a, b) {
        if (a.source > b.source) {
          return 1;
        }
        else if (a.source < b.source) {
          return -1;
        }
        else {
          if (a.target > b.target) {
            return 1;
          }
          if (a.target < b.target) {
            return -1;
          }
          else {
            return 0;
          }
        }
      });

      //any links with duplicate source and target get an incremented 'linknum'
      for (var i = 0; i < links.length; i++) {
        if (i != 0 &&
          links[i].source == links[i - 1].source &&
          links[i].target == links[i - 1].target) {
          links[i].linknum = links[i - 1].linknum + 1;
        }
        else {
          links[i].linknum = 0;
        };
      };

        link = svg.selectAll(".edgepath")
            .data(links)
            .enter()
            .append("svg:path")
            .attrs({
                'class': 'edgepath',
                'fill-opacity': 0,
                'stroke-opacity': 0,
                'id': function (d, i) {return 'edgepath' + i}
            })
            .style("pointer-events", "none")
            .attr('marker-end','url(#arrowhead)');

        edgelabels = svg.selectAll(".edgelabel")
            .data(links)
            .enter()
            .append('text')
            .style("pointer-events", "none")
            .attrs({
                'class': 'edgelabel',
                'id': function (d, i) {return 'edgelabel' + i},
                'font-size': 20,
                'fill': '#aaa'
            });
            edgelabels.append('textPath')
                .attr('xlink:href', function (d, i) {return '#edgepath' + i})
                .style("text-anchor", "middle")
                .style("pointer-events", "none")
                .attr("startOffset", "50%")
                .text(function (d) {return d.relation});

        node = svg.selectAll(".node")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .on('dblclick', releasenode)
            .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended)
            );

        node.append("circle")
            .attr("r", 10)
            .attr("fill", function(d) { return legend[d.type].color; })

        //tooltip?
        node.append("title")
            .text(function (d) {return d.id;});

        node.append("text")
            .attr("dy", -3)
            .text(function (d) {return d.label;});

        simulation
            .nodes(nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(links);
    }

    function ticked() {

        //update nodes position with each simulation tick
        node.attr("transform", function (d) {return "translate(" + d.x + ", " + d.y + ")";});

        //use linknum to set the arc strength (0  = strieght line, while higher values gives an arc) this to allow
        //for 2 nodes to have multi-links and still be able to see links and lables of links
        link.attr("d", function(d) {
            var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y;
            var qx = dy /  1 * d.linknum, //linknum is defined above
            qy = -dx / 1 * d.linknum;
            var qx1 = (d.source.x + (dx / 2)) + qx,
            qy1 = (d.source.y + (dy / 2)) + qy;
            return "M"+d.source.x+" "+d.source.y+" C" + d.source.x + " " + d.source.y + " " + qx1 + " " + qy1 + " " + d.target.x + " " + d.target.y;
        });

        //correct/rotate direction of text as a function of nodes' position
        edgelabels.attr('transform', function (d) {
            if (d.target.x < d.source.x) {
                var bbox = this.getBBox();

                rx = bbox.x + bbox.width / 2;
                ry = bbox.y + bbox.height / 2;
                return 'rotate(180 ' + rx + ' ' + ry + ')';
            }
            else {
                return 'rotate(0)';
            }
        });

    }

function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    // Allows NODE FIXING
    // d.fx = null;
    // d.fy = null;
}
function releasenode(d) {
    d.fx = null;
    d.fy = null;
}


</script>

</body>
</html>